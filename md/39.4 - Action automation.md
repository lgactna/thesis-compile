

This chapter addresses the modules responsible for automating artifact generation, depicted in the partial architectural diagram below. 

!**39.4 - Action automation 2025-02-07 17.15.30.excalidraw**

- [ ] #task include semi-shaded versions of the simpler diagrams here
	- For each subsection, provide a "complex" diagram focusing exclusively on the rectangles implemented for that current section.  For any interfaces that are nut relevant to the current section, have them go to the equivalent labeled "colored" section, but don't put any details for that section – just the fact it's the "action automation library" or the "virtual machine" is fine.
	- For each chapter, describe what it interfaces with to begin with.  Individual sections, which are naturally going to have actual implementation details, can go into lower details.  Keep the detailed diagrams close to the things they're describing – that's only possible if you break the detailed diagram down further by subsection.  
		- regularly use language and figures that reminds the reader of where they are in the broader scope of things 
	- Consider looking into an "interaction"-based diagram, that focuses more on what the components are *doing* rather than the components themselves; I never explain the intentional fact that components on a horizontal line all work together to achieve one *specific* thing. Can call it out explicitly by coloring lines or changing the lines of boxes, or by also just including it in the text; more viable in subsections 

At the core of every synthesizer is the ability to place or otherwise generate forensic artifacts; these modules implement AKF's ability to generate individual artifacts as part of a larger scenario. 

Each of the synthesizers described in **39.2 - Literature review#2.2 - Analysis of existing synthesizers** takes one of three approaches to artifact generation, as partly described by Scanlon et al. [@scanlonEviPlantEfficientDigital2017]:

- **Physical**: No virtualization of software or hardware ever occurs; data is written directly to the target medium, such as a disk image or virtual hard drive. 
- **Agentless logical**: The synthesizer interacts with a live VM to generate artifacts. Interaction is achieved without the need for custom software to be installed on the VM; instead, actions are achieved using the hypervisor itself or a remote management tool native to the virtualized operating system. 
- **Agent-based logical**: The synthesizer interacts with a dedicated client, or agent, on a live VM to carry out actions. The VM must have the agent installed before any interaction can occur. 

These three approaches are not mutually exclusive within a single synthesizer, though many prior synthesizers have used only one approach to generate artifacts. **!table:prior-techniques** below denotes the approaches used by each of the synthesizers previously discussed. Where source code is unavailable, a best effort was made to identify the approach used by a particular synthesizer based on its published paper, if one exists; otherwise, the entire row contains question marks. 

| Synthesizer                                                                             | Physical                                                  | Agentless                   | Agent-based             |
| --------------------------------------------------------------------------------------- | --------------------------------------------------------- | --------------------------- | ----------------------- |
| **FALCON** [@adelsteinAutomaticallyCreatingRealistic2005], 2005                         | ?                                                         | ?                           | ?                       |
| **CYDEST** [@bruecknerAutomatedComputerForensics2008], 2008                             | ?                                                         | ?                           | ?                       |
| **Forensig2** [@mochForensicImageGenerator2009; @mochEvaluatingForensicImage2012], 2009 | Yes (filesystem mounting; filesystem-independent editing) | Yes (over SSH only)         | No                      |
| **D-FET** [@williamCloudbasedDigitalForensics2011], 2011                                | Yes (filesystem mounting; filesystem-independent editing) | No                          | No                      |
| **SFX** [@russellForensicImageDescription2012], 2012                                    | Yes (filesystem mounting)                                 | No                          | No                      |
| **Yannikos et al.** [@yannikosDataCorporaDigital2014], 2014                             | ?                                                         | ?                           | ?                       |
| **ForGeOSI** [@maxfraggMaxfraggForGeOSI2023], 2014                                      | No                                                        | Yes (hypervisor interfaces) | No                      |
| **ForGe** [@vistiAutomaticCreationComputer2015], 2015                                   | Yes (filesystem-aware editing)                            | No                          | No                      |
| **ForGen** [@jjk422Jjk422ForGen2019], 2016                                              | No                                                        | No                          | No                      |
| **EviPlant** [@scanlonEviPlantEfficientDigital2017], 2017                               | Yes (filesystem-independent editing)                      | No                          | Yes (unknown mechanism) |
| **VMPOP** [@parkTREDEVMPOPCultivating2018], 2018                                        | No                                                        | Yes (hypervisor interfaces) | No                      |
| **hystck** [@gobelNovelApproachGenerating2020], 2020                                    | No                                                        | No                          | Yes (Python agent)      |
| **TraceGen** [@duTraceGenUserActivity2021], 2021                                        | No                                                        | No                          | Yes (unknown mechanism) |
| **ForTrace** [@gobelForTraceHolisticForensic2022], 2022                                 | No                                                        | No                          | Yes (Python agent)      |

There are advantages and disadvantages to each approach, in addition to requiring distinct implementation techniques for each. The remainder of this chapter analyzes each of these three approaches in greater detail, describing the implementation details of prior synthesizers and comparing them to those of AKF's.

More specifically, this chapter addresses the functionality of the action automation library (`akflib`) to generate artifacts by either interacting with a live virtual machine or by directly editing disk images stored on the host. We explore how logical artifacts are generated at a lower level using hypervisor APIs and an OS-specific agent running on the virtual machine. We conclude by describing the generation of physical artifacts through direct filesystem and disk image editing.

# 4.1 - Agentless artifact generation

**Agentless artifact creation** describes one of two general techniques. The first is emulating "normal" human interaction by leveraging virtualized human interfaces – such as the monitor, keyboard, and mouse – to directly manipulate a GUI-based operating system. The second is using (remote) management utilities included with the operating system, typically an interactive shell.

AKF allows users to perform agentless artifact creation through a hypervisor-agnostic interface; a concrete implementation of this interface using VirtualBox is provided. This VirtualBox-specific functionality is derived mainly from ForGeOSI [@maxfraggMaxfraggForGeOSI2023], which uses the VirtualBox SDK and a Python implementation of the VirtualBox COM API [@larsonSethmlarsonVirtualboxpython2025] to carry out the vast majority of its tasks. This was adapted in VMPOP [@parkTREDEVMPOPCultivating2018], which also introduced the notion of a generic hypervisor interface that allows for synthesizer routines to use arbitrary hypervisors so long as required functionality is implemented. 

Note that the use of hypervisor-specific guest software, such as VirtualBox Guest Additions and VMWare Tools, is treated as an agentless approach for this thesis. Although this inherently requires installing "unusual" software on the virtual machine, it is very distinct from typical user software. In many cases, artifacts generated by hypervisor guest software can be identified, isolated, and ignored. 

## 4.1.1 - Human interfaces

The use of human input devices – the keyboard and mouse – is the primary approach taken by VMPOP [@parkTREDEVMPOPCultivating2018] and ForGeOSI [@maxfraggMaxfraggForGeOSI2023] to generate artifacts. For example, VMPOP uses a sequence of keyboard strokes to focus and interact with UI elements, such as clearing User Account Control dialogs on Windows or starting applications with Win+R. It achieves this by making calls to the VirtualBox API, which issues scancodes to the virtual machine.

This approach most accurately reflects how an actual human would interact with a machine. As a result, this greatly reduces the **Synthesis pollution** that occurs as a result of generating artifacts. However, this often leads to verbose scripts that are only capable of performing very specific actions. The keyboard and mouse actions required to fulfill a particular action can change significantly between versions of the same application, versions of the same operating system, and varying screen sizes. For example, VMPOP handles User Account Control (UAC) prompts on machines prior to Windows 7 by sending an Alt+Tab keystroke to the machine, clicking the mouse at the center of the screen to focus the UAC prompt, and then sending Alt+C to accept the prompt. On machines running Windows 7 or later, this is instead achieved by focusing the UAC prompt with the mouse and then sending Alt+Y to accept the prompt. 

Similarly, VMPOP interacts with browsers exclusively through the use of keyboard shortcuts. VMPOP supports simple interactions with a small number of websites, such as logging into Microsoft or Google accounts, but is dependent on the form elements remaining the same over time. That is, VMPOP does not inspect the contents of the current webpage to perform actions; it cannot react to design changes. If the page has new focusable elements, the same keystroke sequence may no longer achieve the desired effects. This lack of runtime logic, which amounts to operating a computer with the monitor off, leads to brittle scripts that can be tedious to fix and update.

AKF's VirtualBox implementation allows the user to issue mouse events at absolute coordinates, though it does not support general mouse movement, such as clicking and dragging. It also allows the user to issue a sequence of press-and-release events while holding down specified keys. While this is theoretically sufficient to emulate nearly all actions that a human would normally perform with a mouse and keyboard, the AKF agent (as described in **39.4 - Action automation#4.2.2 - The AKF agent**) also exposes a more flexible mouse and keyboard automation API. More generally, the AKF agent leverages automation frameworks capable of runtime UI analysis, reducing the inflexibility of application-specific scripts.

TraceGen [@duTraceGenUserActivity2021] notes that the ideal future is to use computer vision and AI to automate user actions from high-level prompts. Performing a Google search in a specific browser would currently require a sequence of predefined keystrokes, assuming an agentless approach is needed. While this is explored in greater detail in **39.8 - Future work#8.1 - Open-ended automation with AI**, recent advancements in LLMs may make it possible to allow a machine to perform arbitrarily complex tasks on a GUI-based operating system using natural language – an approach that can be integrated into AKF in the future. 

## 4.1.2 - Management utilities

The alternative is to use existing management utilities, typically a shell, which are native to the virtualized operating system and are capable of carrying out commands. This approach can also be divided into two categories: local management utilities, such as Bash and PowerShell, and remote management utilities, such as SSH and WinRM.

Local management utilities typically refer to scripting languages that are available as part of the operating system and can be used to manage most or all operating system resources. For example, PowerShell allows users to modify registry keys, invoke applications, create users, and more. Similarly, any standard Linux shell, such as Bash or Zsh, can be used to install packages and run various command-line applications. These shells can be invoked by either opening and focusing a terminal window (for example, through the Win+R shortcut on Windows) or directly executing scripts through hypervisor guest additions. 

In particular, VMPOP [@parkTREDEVMPOPCultivating2018] makes heavy use of local management utilities; it implements much of its functionality through a collection of PowerShell and batch scripts. For example, VMPOP allows users to focus a window by process ID, process name, or window title. This is achieved by getting a PowerShell handle to the process using `Get-Process`, using `Add-Type` to add a local C# function that is capable of sending keyboard events through `user32.dll`, and then holding the Alt key while using `AppActivate` to focus the window and bring it to the foreground. VMPOP leverages similar scripts for launching and terminating processes by name, uninstalling programs, creating a Windows restore point, and more. 

Similarly, remote management utilities allow a remote device to invoke local management utilities, typically over an SSH server or WinRM. In most synthesizer architectures, remote management utilities require that the host and guest machines can communicate with each other. This is typically achieved through a NAT or host-only interface managed by the hypervisor. This approach is taken by Forensig2 [@mochForensicImageGenerator2009], which exclusively connects to a running SSH server on a virtual machine to carry out user actions. 

The use of remote management utilities to automate actions typically undertaken by users is not uncommon, especially with the prevalence of infrastructure as code solutions. For example, the open-source Ansible framework simplifies the configuration of Windows and Linux devices to simple, YAML-based files called "playbooks." These playbooks contain a sequence of high-level tasks to perform, such as installing packages, managing local user accounts, and running scripts, which are executed on multiple remote machines in parallel. (This high-level scripting language is the inspiration for AKF's high-level scripting language, described in **39.6 - Building scenarios#6.3 - Declarative usage**.)

It is worth noting that although this approach does not require installing new software on the machine, most operating systems perform some degree of logging when their management utilities are invoked. For example, the `sshd` daemon logs connections regardless of whether a NAT or host-only network interface is used. This behavior may make it difficult to separate or remove logs unrelated to a scenario. Similarly, the invocation of PowerShell scripts generates event logs, which can be particularly noisy if Script Block Logging (which logs the execution and content of all PowerShell scripts) is enabled.

AKF inherits the capabilities of VMPOP, allowing users to leverage the VirtualBox API and Guest Additions to execute arbitrary processes. For example, users can invoke scripts to automate OS-specific configuration, such as using PowerShell to set registry keys. However, AKF does not currently implement any agentless OS- or application-specific functionality through this method; many of the actions and artifacts previously generated through OS-specific scripts in VMPOP [@parkTREDEVMPOPCultivating2018] and other synthesizers can be implemented with greater flexibility through the agent. How this flexibility is achieved, as well as why it is the preferred method for implementing application-specific functionality, is described in the following section.

# 4.2 - Agent-based artifact generation

**Agent-based artifact creation** involves the use of a dedicated program on the VM that serves as an interface between the host machine and the guest machine. This program runs commands natively on the virtual machine on behalf of the host machine, accepting commands over a dedicated network interface. This allows for greater flexibility and more complex actions to be taken when compared to agentless approaches. In particular, it allows application-specific functionality to be implemented using existing automation frameworks such as Selenium [@SeleniumHQSelenium2025], Playwright [@MicrosoftPlaywrightpython2025], and PyAutoGUI [@sweigartAsweigartPyautogui2025]. However, this approach often leads to **synthesis pollution**; besides the presence of software that would never exist on a typical user's machine, agents often do not interact with applications the same way that a human would. As a result, the synthesizer should document known pollution that can be ignored for educational and testing purposes. 

## 4.2.1 - Analysis of the ForTrace agent

Agent-based artifact creation is the approach taken by hystck/ForTrace [@gobelNovelApproachGenerating2020; @gobelForTraceHolisticForensic2022], which refers to its agent as an "interaction manager." Because ForTrace provides extensive agent functionality and is by far the most mature synthesizer, AKF's agents borrow heavily from ForTrace's approach. We briefly describe ForTrace's implementation of agents here, with a more detailed analysis in **39.B - Code samples#Comparison of ForTrace and AKF agents**.

ForTrace agents are simply an entire copy of the ForTrace codebase copied over to the virtual machine – that is, the "agent" and "server" share the same codebase but have different entry points and use different parts of the ForTrace library. Communication between the agent and the server occurs over a dedicated TCP socket using a simple ASCII-based protocol; to execute commands, the server sends a space-delimited string containing the application, function, and arguments to run. Results are similarly returned by the agent as structured ASCII messages. These messages are typically sent over a dedicated "management" network interface to exclude them from network captures for scenario-related activities. 

Application-specific functionality for agents is organized into individual files (Python modules), where each file includes a set of commands or actions for a single application. These files contain both server-side code (the logic for *constructing* the ASCII message) and agent-side code (the logic for *interpreting* the message and *executing* the command) as a set of classes with a common prefix. This common prefix is used to automatically discover the corresponding agent-side code given a command issued by the server-side code.

Two key implementation details should be noted here. First, commands are sent through a simple string-based protocol. This simplicity makes it easy to debug issues arising from the protocol itself, but is relatively inflexible as a result. In particular, it is challenging to send complex Python objects as arguments or return values since these objects often cannot be easily serialized to a string without loss of information. An example relevant to AKF is passing Playwright browser objects, which contain an internal state that is difficult to extract and reconstruct using strings alone.

The second implementation detail involves the discovery and execution of commands indicated by the protocol. ForTrace depends on Python's runtime introspection to discover the correct modules and functions to call based on the contents of a command string, importing these modules during runtime. While this is a valid approach, it is more complex (and difficult to follow) than the approach taken by AKF.

## 4.2.2 - The AKF agent

AKF borrows heavily from the Python agent-based approach of ForTrace but improves upon its architecture in several respects. Details of low-level improvements over ForTrace's agent architecture are described in more detail in **39.B - Code samples#Comparison of ForTrace and AKF agents**.

Perhaps the most significant difference is the use of RPyC, a library for symmetric remote procedure calls, for agent communication [@TomerfilibaorgRpyc2025]. Although the RPyC protocol is symmetric, it is often used in typical client-server architectures to allow clients to manipulate remote Python objects as if they were local objects, as well as invoke remote (server) functions using local (client) parameters. Delegating the serialization and deserialization of complex objects to RPyC allows us to perform complex operations that would have been difficult to implement with the simple string-based protocol of ForTrace.

In "new-style" RPyC, this is achieved by running a *service* on the device where remote operations should be performed. Services expose a set of functions and attributes that may be accessed remotely by an RPyC client, listening on a specified TCP port for requests to access these exposed elements. Clients access these functions and attributes by name as if they were local objects; arguments passed to functions are serialized and deserialized in the background, as are the results of function calls and attribute accesses.

AKF's application-specific functionality is divided into individual RPyC "subservices" created on demand. The agent's main loop is itself a "root" RPyC service that is responsible for creating and destroying these subservices upon request; all subservices are known to the root service at initialization, eliminating the need to perform runtime introspection to find application-specific modules. These subservices are analogous to the agent-side code of individual ForTrace modules, interpreting arguments and executing commands on behalf of the host machine. 

Clients are largely decoupled from the server's implementation of individual services; they do not directly call or import RPyC service functions. Instead, they call these functions by name from an untyped connection object. Because the exposed functions (as well as their signatures) and attributes cannot be inferred from the raw RPyC connection alone, clients can implement a typed, concrete API to construct RPyC calls. This abstracts the raw RPyC call (and the existence of an RPyC connection) away from the user while also providing the signatures of remote functions where there would otherwise be none. This allows for type checking and autocompletion during development. This is analogous to the client-side code of individual ForTrace modules, constructing messages to the agent to execute commands. 

Additionally, because the RPyC service and the API to that service are separable, this allows us to break the API (which is used in scenario scripts) and the agent logic itself into two separate libraries. This has two advantages – it makes it significantly easier to build and generate standalone executables using tools like PyInstaller [@PyinstallerPyinstaller2025], and it may also slightly reduce the size of the agent when installed onto the virtual machine. Unlike ForTrace, whose agent installation process requires a batch script installing various libraries and Python through the Chocolatey package manager, AKF's agent only requires that a single executable is copied over and configured to run on startup (in addition to setting relevant firewall rules). The agent setup process can be further simplified using Vagrant, which is described in **39.6 - Building scenarios#6.2 - Setup and basic usage**.

From an implementation and usability perspective, this design provides three significant improvements over the ForTrace protocol. First, the routing of functions is wholly delegated to RPyC. Instead of manually constructing a message with the function name and its associated parameters (as strings) over the network, the process of serializing parameters and routing them to the correct function call is abstracted away by RPyC. 

Second, this allows us to pass and return arbitrarily complex objects (for which we do not have to manually write the serialization and deserialization logic). When passing complex objects from the agent to the server or vice versa, a reference to the object is sent over the network and wrapped by a *proxy object*, which behaves like the original object [@TheoryOperationRPyC]. Importantly, it is not necessary to distinguish between local and remote/proxy objects of the same type when writing code, which eliminates the extra complexity of using proxies.

Finally, the ability to interact with complex remote objects allows us to significantly reduce the actual code written as part of the API exposed to the host. For example, there is no need to implement a wrapper for every method available as part of a Playwright page object; instead, a reference to the Playwright object *running on the virtual machine* can be given to the host machine. Instead of writing individual methods for opening pages, navigating to specific elements, and so on, we can simply use the methods that already exist in the Playwright object – any local calls on the host's proxy object will lead to remote outcomes on the host, as desired. This, of course, does not preclude the ability to write convenience methods for more complex actions requiring the Playwright object. 

The list of applications supported by the AKF Windows agent is described in **the table** below. 

| Module   | Dependencies                                | Details                                                                                                                                                            |
| -------- | ------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Chromium | Playwright [@MicrosoftPlaywrightpython2025] | Allows arbitrary webpages to be visited on Chrome and Edge, as well as perform complex actions such as completing forms and clicking links based on HTML selectors |
The generic hypervisor interface is used to support agent discovery and communication. To avoid polluting network captures with agent-related packets, virtual machines are expected to use a NAT adapter for Internet communications and a "maintenance" host-only adapter for agent-specific communications. In turn, hypervisor-specific implementations must expose the ability to discover the IP address of the host-only adapter. This allows AKF scripts to communicate with the root RPyC service and any subservices over the host-only adapter, concealing them from network captures on the NAT adapter.

# 4.3 - Physical artifact generation

## 4.3.1 - Overview

Physical artifact creation encompasses any technique in which virtualization of an operating system is not used to generate artifacts. This allows the synthesizer to bypass the operating system or related software that could lead to undesirable non-deterministic behavior. This is sometimes called *simulating* the creation of artifacts rather than *virtualizing* their creation.

For example, a scenario developer may want to guarantee that a particular deleted file is partially overwritten by another file, ensuring that the deleted file is recoverable from the slack space of the newly placed file. However, it is extremely difficult to force the reuse of the same physical disk clusters from a userspace application. Operating systems rarely expose low-level filesystem functionality to applications; furthermore, operating systems are still subject to hardware drivers that regularly rearrange physical space, such as those that engage in wear leveling. 

While it may be possible to predict the outcome of these wear leveling techniques, as demonstrated by Neyaz et al., this is far from the determinism necessary for research and tool validation [@neyazForensicAnalysisWear2018]. Additionally, background programs and services may perform file operations that are difficult to predict. Finally, there is hardware-related non-determinism, such as that caused by faulty hardware or cosmic rays. (There is ongoing work in building deterministic platforms, such as the deterministic hypervisor developed by Antithesis [@pshenichkinYouThinkYou2024]. Such platforms are outside the scope of this thesis but could be integrated into synthesizers in the future.) 

In turn, it is sometimes necessary to bypass the operating system to reliably place data on a disk. Two primary strategies are used to achieve physical artifact creation.

The first strategy is mounting the filesystem and performing typical read/write operations. Filesystem mounting is used by several synthesizers, including Forensig2 [@mochForensicImageGenerator2009] and SFX [@russellForensicImageDescription2012]. For both of these synthesizers, physical artifact creation is achieved by simply allowing the user to specify a file to copy from the host machine to a specific file path on the disk image. 

The second strategy is performing writes directly to the underlying disk image, bypassing the filesystem entirely. For example, ForGe [@vistiAutomaticCreationComputer2015] maintains a virtual representation of supported filesystems, using its own data structures to represent a FAT32/NTFS filesystem. This allows it to quickly identify and place data in unallocated or slack space. In contrast, synthesizers such as EviPlant [@scanlonEviPlantEfficientDigital2017] simply allow the user to provide an offset into the disk image where arbitrary data will be written. Both techniques involve directly writing to specific physical addresses, with the only distinction being filesystem awareness.  

It is theoretically possible to construct complete forensic datasets through simulation alone. If a user knows what artifacts are generated through the execution of an application and how these artifacts are generated, it may be possible to artificially generate these artifacts as if the application had actually been running. An example may be editing the history database of a particular browser contained on a filesystem by mounting it, parsing it, and adding new entries; this would make it appear as if the machine was used to browse these websites without requiring virtualization.

However, this technique is challenging to implement in practice. For example, a scenario developer would need to ensure that the artifact is consistent with other artifacts on disk, since typical Windows application usage would generate relevant artifacts in prefetch files and jump lists. Additionally, physical artifact creation does not lend itself well to generating network captures and volatile memory. Because no operating system is virtualized, it is naturally the case that there are no applications making network requests or using volatile memory as part of execution. Building a network capture or volatile memory dump from scratch is difficult, at best.  

It is important to note that most artifacts generated by physical techniques can still be created non-deterministically through logical means. A user could create files of interest, delete them, and then write new files to disk through a virtual machine, possibly leading to the same outcome as simply writing these files directly to the filesystem without virtualization. As described previously, there is no guarantee that the new files will occupy the same physical clusters as the deleted files. However, this may be acceptable, such as a scenario in which an instructor merely wants to demonstrate examples of what could occur when deleting a file. If there is no need to carve deleted files from slack or unallocated space reliably, then logical approaches are sufficient.

## 4.3.2 - AKF implementation

As described in the prior section, there are three techniques for physical artifact planting implemented by prior synthesizers. These are:

- **Filesystem mounting**, as done by Forensig2 [@mochForensicImageGenerator2009] and SFX [@russellForensicImageDescription2012], in which the filesystem is mounted to the host and edited directly.
- **Filesystem-independent direct editing**, as done by EviPlant [@scanlonEviPlantEfficientDigital2017], in which edits to specific physical addresses on the disk image are made without any parsing or knowledge of the underlying filesystem.
- **Filesystem-aware direct editing**, as done by ForGe [@vistiAutomaticCreationComputer2015] and EviPlant [@scanlonEviPlantEfficientDigital2017], in which filesystem data structures are parsed to determine the physical address(es) of the disk image to write to. (How EviPlant achieves this is not known.)

AKF supports all three to varying degrees, with significant improvements in filesystem-aware editing over prior synthesizers.  

First, AKF does not currently support mounting and writing to arbitrary filesystems or disk image formats, though this could be implemented with external image mounting software with the assistance of filesystem-independent libraries such as PyFilesystem [@PyFilesystemPyfilesystem22025]. However, AKF allows users to construct new ISO files from an existing host directory using the `pycdlib` library [@lalancetteClalancettePycdlib2025]. These ISOs can be used as standalone artifacts (for example, presenting them to students as disk images of removable drives) or as removable storage on a running virtual machine. Mounting these ISOs, as well as setting up a shared network folder between the host and guest machines, are the simplest means through which scenario developers can transfer files onto a running virtual machine.

Second, AKF also trivially "supports" filesystem-independent direct editing. Python allows users to open files in binary mode, at which point the user can call `seek()` on the file pointer to advance the pointer to a specific offset in the file. The user can then call `write()` to overwrite an arbitrary number of bytes at that position, achieving the same outcome as many other synthesizers that implement range and offset-based disk image editing. 

Although writing to arbitrary positions is not always viable for correctly placing artifacts on a disk image, it is still a valid approach when the underlying filesystem has already been analyzed and the exact offsets and ranges to write are known. This may be the approach used by EviPlant [@scanlonEviPlantEfficientDigital2017] to construct and leverage its evidence packages for students; because filesystem analysis is costly and requires additional libraries not needed for offset-based editing, it is easier to perform this analysis at construction time and distribute the offsets to which data must be written to base images. 

However, the filesystem may not have been analyzed ahead of time such that the exact offsets and data needed to place a file on disk are known. This brings us to filesystem-aware direct editing, in which AKF makes significant improvements.

ForGe implements its physical artifact generation by implementing NTFS and FAT32 data structures in Python, allowing it to create a fully virtual representation of these filesystems (with the assistance of a custom C program). This virtualized filesystem provides ForGe with the information necessary to efficiently insert data into known slack and unallocated space while maintaining filesystem consistency. While extremely powerful (and implements a valuable feature not found in any other synthesizer to date), it is inflexible in two specific aspects:

- ForGe does not provide a generic interface for the filesystems it supports. Although the NTFS and FAT32 wrappers provide the same methods with the same signatures, this is not strictly enforced by a parent class. The lack of a generic interface means that the functionality supported across all filesystems is unclear, as is the functionality that must be implemented for new filesystems to be compatible with ForGe.
- ForGe lacks a "frontend" to support arbitrary disk types, regardless of the underlying filesystem. ForGe does not support multi-partition disks or common non-raw disk formats such as VHD, VMDK, or VDI.

Read-only libraries addressing these two issues have been in development since the introduction of ForGe but have not been integrated into other synthesizers to achieve the same write capabilities as ForGe. One such library is `libtsk` (also known as The Sleuth Kit), the C++ library that powers the open-source digital forensics platform Autopsy [@SleuthkitSleuthkit2025]. `libtsk` allows users to navigate and analyze the low-level contents of a variety of filesystems, including filesystem-specific attributes and the sequence of disk clusters that form a file. `libtsk` supports a large variety of filesystems through a filesystem-agnostic interface, including the FAT family of filesystems, the ext family, NTFS, and a variety of other filesystems.  It also supports various volume systems for multi-partition disks, such as GPT and MBR, as well as several filesystem containers and images. 

Python bindings for `libtsk` have existed for at least 15 years, with the most commonly used library being the automatically generated `pytsk` [@Py4n6Pytsk2025]. However, `pytsk` has relatively limited Python documentation and adoption, in addition to inheriting various known issues and limitations in `libtsk`, such as support for niche filesystems and partitioning formats. Many of these gaps were gradually covered as part of the `libyal` project, a collection of DFIR libraries developed by various contributors - most notably Joachim Metz from Google [@LibyalLibyal2025]. The `libyal` project includes individual libraries for analyzing formats not supported by `libtsk`, such as the QCOW disk image format used by QEMU, the Apple File System used by modern Apple devices, and more.

These libraries eventually led to the development of `dfvfs`, or the Digital Forensics File System, a Python library that leverages `libtsk` and multiple libraries from the `libyal` project to provide a generic interface for analyzing a variety of disk image formats and filesystems [@Log2timelineDfvfs2025]. (The project is derived from Plaso and Google Rapid Response, two open-source DFIR tools used in various contexts.) Much like `libtsk`, it exposes a variety of low-level filesystem concepts common across multiple filesystems, such as the metadata and individual segments comprising a file at a known path on the filesystem. This low-level detail makes it extremely powerful in performing filesystem-aware direct editing, especially because of its focus on exposing this detail through a consistent Python interface.

AKF uses `dfvfs` to locate the clusters of a file at a known path in a filesystem, which can then be used to identify the start of slack space within the file's clusters (as well as unallocated space in the filesystem). By adding the physical offset of the cluster within the filesystem to the offset of the filesystem's partition in the disk image, AKF can write to the exact location of a file's slack space using the offset-based method described earlier. This achieves feature parity with ForGe, completely delegating filesystem and image-specific details to `dfvfs` and allowing for a filesystem-independent method for locating slack space. 

More generally, this technique provides a deterministic method for inserting data within the slack space of a filesystem, simulating the deallocation of a file and its partial replacement with a known file. However, this does not fully simulate the process of deleting a file through a running operating system and having a new file replace the deallocated clusters; naturally, this does not generate OS-specific artifacts associated with deleting and creating files and fails to generate the filesystem artifacts that could exist with the original file (such as the "deleted" file's name in the NTFS master file table). Future work in the field could address this gap by combining `dfvfs` with additional technologies to improve the accuracy of physical techniques.

It should be noted that this technique does not work on filesystems with full disk encryption enabled, as is the default on Windows systems beginning with the Windows 11 24H2 update. Additionally, this technique has only been verified to work on raw disk image formats. From limited testing, the offsets of partitions and files on compacted formats such as VHD are reported by `dfvfs` as if the partition were not compact, which makes it difficult to correctly determine the physical offset of a file on a VHD image. Additional research is needed to develop a reliable method for performing filesystem-aware physical artifact generation on such disk image formats.