This chapter addresses the modules responsible for automating artifact
generation, depicted in the partial architectural diagram below.

!\textbf{39.4 - Action automation 2025-02-07 17.15.30.excalidraw}

\begin{itemize}
\tightlist
\item[$\square$]
  \#task include semi-shaded versions of the simpler diagrams here

  \begin{itemize}
  \tightlist
  \item
    For each subsection, provide a ``complex'' diagram focusing
    exclusively on the rectangles implemented for that current section.
    For any interfaces that are nut relevant to the current section,
    have them go to the equivalent labeled ``colored'' section, but
    don't put any details for that section -- just the fact it's the
    ``action automation library'' or the ``virtual machine'' is fine.
  \item
    For each chapter, describe what it interfaces with to begin with.
    Individual sections, which are naturally going to have actual
    implementation details, can go into lower details. Keep the detailed
    diagrams close to the things they're describing -- that's only
    possible if you break the detailed diagram down further by
    subsection.

    \begin{itemize}
    \tightlist
    \item
      regularly use language and figures that reminds the reader of
      where they are in the broader scope of things
    \end{itemize}
  \item
    Consider looking into an ``interaction''-based diagram, that focuses
    more on what the components are \emph{doing} rather than the
    components themselves; I never explain the intentional fact that
    components on a horizontal line all work together to achieve one
    \emph{specific} thing. Can call it out explicitly by coloring lines
    or changing the lines of boxes, or by also just including it in the
    text; more viable in subsections
  \end{itemize}
\end{itemize}

These implement AKF's ability to generate individual artifacts as part
of a larger scenario dataset. This chapter begins with an overview of
the techniques used by prior synthesizers for generating artifacts. It
then moves to a low-level analysis of the actual implementation used by
AKF, while comparing these techniques to other synthesizers.

In particular, this chapter addresses the role of the action automation
library in generating artifacts by interacting with a live virtual
machine and disk images stored on the host. It describes how logical
artifacts are generated at a lower level, both directly through
hypervisor APIs and through an OS-specific agent installed on the
virtual machine. It concludes by describing the generation of physical
artifacts through direct filesystem and disk image editing.

\section{Overview}\label{overview}

At the core of every synthesizer is the ability to place or otherwise
generate forensic artifacts. Each of the synthesizers described in
\autoref{analysis-of-existing-synthesizers} takes one of three approaches to artifact generation, as
partly described by Scanlon et al.
\cite{scanlonEviPlantEfficientDigital2017}:

\begin{itemize}
\tightlist
\item
  \textbf{Physical}: No virtualization of software or hardware ever
  occurs; data is written directly to the target medium, such as a disk
  image or virtual hard drive.
\item
  \textbf{Agentless logical}: The synthesizer interacts with a live VM
  to generate artifacts. Interaction is achieved without the need for
  custom software to be installed on the VM, and is typically achieved
  through the hypervisor itself or a remote management tool native to
  the virtualized operating system.
\item
  \textbf{Agent-based logical:} The synthesizer interacts with a
  dedicated client (agent) on a live VM to carry out actions. The VM
  must have the agent installed before any interaction can occur.
\end{itemize}

These three approaches are not mutually exclusive within a single
synthesizer, though it is the case that most prior synthesizers have
used exactly one approach to generate artifacts. The table below denotes
the approaches used by each of the synthesizers previously discussed.
Where source code is not available, a best effort is made to identify
the approach used by a particular synthesizer based on its published
paper, if one exists; otherwise, the entire row contains question marks.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1799}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.4604}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1942}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1655}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Synthesizer
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Physical
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Agentless
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Agent-based
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{FALCON}, 2005 & ? & ? & ? \\
\textbf{CYDEST}, 2008 & ? & ? & ? \\
\textbf{Forensig2}, 2009 & Yes (mounting filesystem, writing directly to
disk using offset) & Yes (over SSH only) & No \\
\textbf{D-FET}, 2011 & Yes (mounting filesystem, writing directly to
disk using offset) & No & No \\
\textbf{SFX}, 2012 & Yes (mounting filesystem) & No & No \\
\textbf{Yannikos et al.}, 2014 & ? & ? & ? \\
\textbf{ForGeOSI}, 2014 & No & Yes (hypervisor interfaces) & No \\
\textbf{ForGe}, 2015 & Yes (emulates complete filesystem in memory as
Python objects) & No & No \\
\textbf{ForGen}, 2016 & No & No & No \\
\textbf{EviPlant}, 2017 & Yes (write directly to image file using
offset) & No & Yes (unknown mechanism) \\
\textbf{VMPOP}, 2018 & No & Yes (hypervisor interfaces) & No \\
\textbf{hystck}, 2020 & No & No & Yes (Python agent) \\
\textbf{TraceGen}, 2021 & No & No & Yes (unknown mechanism) \\
\textbf{ForTrace}, 2022 & No & No & Yes (Python agent) \\
\end{longtable}

There are advantages and disadvantages to each approach, in addition to
requiring distinct implementation techniques for each. The remainder of
this chapter analyzes these each of these three approaches in greater
detail, describing the implementation details of prior synthesizers and
comparing them to those of AKF's.

\section{Agentless artifact
generation}\label{agentless-artifact-generation}

\textbf{Agentless artifact creation} describes one of two general
techniques. The first is emulating ``normal'' human interaction by
leveraging human interfaces -- such as the monitor, keyboard, and mouse
-- to manipulate a GUI-based operating system directly. The second is
using (remote) management utilities included with the operating system,
typically an interactive shell.

AKF allows users to perform agentless artifact creation through a
dedicated hypervisor-agnostic interface, for which a concrete
implementation using VirtualBox is provided. The VirtualBox-specific
functionality is largely derived from \textbf{ForGeOSI}, which uses the
VirtualBox SDK and a Python implementation of the VirtualBox COM API to
carry out the vast majority of its tasks. This was adapted in
\textbf{VMPOP}, which also introduced the notion of a generic hypervisor
interface that allows for synthesizer routines to use arbitrary
hypervisors so long as required functionality is implemented.

It is worth noting that throughout this thesis, the use of
hypervisor-specific guest software, such as VirtualBox Guest Additions
and VMWare Tools, is treated as an agentless approach. Although this
inherently requires the installation of ``unusual'' software on the
virtual machine, it is sufficiently distinct from typical user software
that it is unlikely to generate artifacts that complicate a scenario. In
many cases, artifacts generated by hypervisor guest software can be
noted, isolated, and ignored.

\subsection{Human interfaces}\label{human-interfaces}

The use of human input devices, namely the keyboard and mouse, is the
primary approach taken by \textbf{VMPOP} and \textbf{ForGeOSI} to
generate artifacts. For example, VMPOP leverages the VirtualBox API to
interact with supported applications. More precisely, it typically uses
a sequence of keyboard strokes to focus and interact with UI elements,
such as clearing User Account Control dialogs on Windows or starting
applications with Win+R.

Strictly speaking, this approach most accurately reflects how a real
human would interact with a machine. In many cases, this greatly reduces
the \textbf{Synthesis pollution} that occurs. However, this tends to
lead to verbose scripts that are only capable of performing very
specific actions. The keyboard and mouse actions required to fulfill a
particular action can change significantly between versions of the same
application, versions of the same operating system, and varying screen
sizes.

For example, VMPOP handles User Account Control (UAC) prompts on
machines prior to Windows 7 by sending an Alt+Tab keystroke to the
machine, clicking the mouse at the center of the screen to focus the UAC
prompt, and then sending Alt+C to accept the prompt. On machines running
Windows 7 or later, this is instead achieved by focusing the UAC prompt
with the mouse and then sending Alt+Y to accept the prompt.

Similarly, VMPOP interacts with browsers exclusively through the use of
keyboard shortcuts. VMPOP supports simple interactions with a small
number of websites, such as logging into Microsoft or Google, but is
dependent on the form elements remaining the same over time. That is,
VMPOP does not inspect the contents of the current webpage to perform
actions, and cannot react to design changes. If there are new focusable
elements on the page, the same keystroke sequence may no longer achieve
the desired effect. This lack of runtime logic, which amounts to
operating the machine with the monitor off, leads to brittle scripts
that can be tedious to fix.

AKF's VirtualBox implementation allows the user to issue mouse events at
absolute coordinates, though it does not support general mouse movement,
such as clicking while dragging. It also allows the user to issue a
sequence of press-and-release events while holding down specified keys.
While this is theoretically sufficient to emulate nearly all actions
that a human would normally perform with a mouse and keyboard, the AKF
agent (as described in \autoref{the-akf-agent}) also exposes a more flexible mouse and keyboard automation API.

\textbf{TraceGen} notes that the ideal future is to use some combination
of computer vision and AI to generalize user actions. Currently,
completing the action of ``performing a Google Search in Microsoft
Edge'' would likely be achieved through a sequence of predefined
keystrokes. While this is explored in greater detail in \autoref{open-ended-automation-with-ai}, recent advancements
in LLMs may make it possible to allow a machine to perform arbitrarily
complex tasks on a GUI-based operating system using natural language -
an approach that can be integrated into AKF in the future.

\subsection{Management utilities}\label{management-utilities}

The alternative is to use existing management utilities, typically a
shell, which are native to the virtualized operating system and are
capable of carrying out commands. This can be further broken down into
two categories: local management utilities, such as Bash and PowerShell,
and remote management utilities, such as SSH and WinRM.

Local management utilities typically refer to scripting languages that
are available as part of the operating system, and can be used to manage
most or all operating system resources. For example, PowerShell allows
users to modify registry keys, invoke applications, create users, and
more. Similarly, any standard Linux terminal program, such as Bash or
Zsh, can be used to install packages and run a variety of command-line
applications. This is typically invoked by either opening and focusing a
terminal window (such as the Win+R shortcut on Windows), or by directly
executing scripts through the hypervisor guest additions.

In particular, \textbf{VMPOP} makes heavy use of local management
utilities; it implements much of its functionality through a collection
of PowerShell and batch scripts. For example, VMPOP allows users to
focus a window by process ID, process name, or window title. This is
achieved by getting a PowerShell handle to the process using
\passthrough{\lstinline!Get-Process!}, using
\passthrough{\lstinline!Add-Type!} to add a local C\# function that is
capable of sending keyboard events through
\passthrough{\lstinline!user32.dll!}, and then holding the Alt key while
using \passthrough{\lstinline!AppActivate!} to focus the window and
bring it to the foreground. VMPOP leverages similar scripts for
launching and terminating processes by name, uninstalling programs,
creating a Windows restore point, and more.

Similarly, remote management utilities allow a remote device to invoke
local management utilities, typically over an SSH server or WinRM. In
most architectures, the use of remote management utilities requires that
the host and guest machines can communicate with each other, which is
typically achieved through a NAT or host-only interface managed by the
hypervisor. This approach is taken by \textbf{Forensig2}, which
exclusively connects to a running SSH server to carry out user actions.

The use of remote management utilities to automate actions typically
undertaken by users is not uncommon, especially among general
infrastructure as code solutions. For example, the open-source Ansible
framework simplifies the configuration of Windows and Linux devices to
simple, YAML-based files called ``playbooks''. These playbooks typically
contain a sequence of high-level tasks to perform, such as installing
packages, managing local user accounts, running scripts, and more. (This
high-level scripting language is the inspiration for AKF's high-level
scripting language, described in \autoref{declarative-usage}.)

It is worth noting that although this approach does not require
installing new software on the machine, most operating systems perform
some degree of logging when their management utilities are invoked. For
example, the \passthrough{\lstinline!sshd!} daemon logs connections
regardless of which network interface is used, which may make it
difficult to separate or remove logs not related to SSH connections as
part of the scenario itself. Similarly, the invocation of PowerShell
scripts causes event logs to be generated, which can be particularly
noisy if Script Block Logging (which logs the execution and content of
all PowerShell scripts) is active.

AKF inherits the capabilities of VMPOP, allowing users to leverage the
VirtualBox API and Guest Additions to execute arbitrary processes. For
example, users can invoke scripts to automate OS-specific configuration,
such as the use of PowerShell to set registry keys. However, AKF does
not currently implement any agentless OS- or application-specific
functionality through this method; many of the actions and artifacts
previously generated through OS-specific scripts in \textbf{VMPOP} and
other synthesizers can be implemented with greater flexibility through
the agent instead. How this flexibility is achieved, as well as why it
is the preferred method for implementing application-specific
functionality, is described in the following section.

\section{Agent-based artifact
generation}\label{agent-based-artifact-generation}

\textbf{Agent-based artifact creation} involves the use of a dedicated
program on the VM that serves as an interface between the host machine
and the guest machine. This program runs commands natively on the
virtual machine on behalf of the host machine, typically accepting
commands over a dedicated network interface. This allows for greater
flexibility and more complex actions to be taken. In particular, it
allows for existing automation frameworks such as Playwright and
PyAutoGUI to be used in implementing application-specific functionality.
However, this approach often leads to \textbf{Synthesis
pollution\textbar synthesis pollution}; besides the presence of software
that would never exist on a typical user's machine, agents often do not
interact with applications the same way that a human would. In this
case, the synthesizer should document known pollution that can be
ignored for educational and testing purposes.

\subsection{Analysis of the ForTrace
agent}\label{analysis-of-the-fortrace-agent}

Agent-based artifact creation is the approach taken by
\textbf{hystck}/\textbf{ForTrace}, which refers to its agent as an
``interaction manager''. Because ForTrace provides the largest set of
functionality for its agents, and is by far the most mature synthesizer,
AKF's agents borrow heavily from ForTrace's approach. We briefly
describe ForTrace's implementation of agents here, with a more detailed
analysis in \autoref{comparison-of-fortrace-and-akf-agents}.

ForTrace agents are simply an entire copy of the ForTrace codebase
copied over to the virtual machine -- that is, the ``agent'' and
``server'' share the same codebase, but have different entrypoints and
use different parts of the ForTrace library. Communication between the
agent and the server occurs over a dedicated TCP socket using a simple
ASCII-based protocol; to execute commands, the server sends a
space-delimited string containing the application, function, and
arguments to run. Results are similarly passed back by the agent as
structured ASCII messages. These messages are typically sent over a
dedicated ``management'' network interface to exclude them from network
captures for other relevant activities.

Application-specific functionality for agents is organized into
individual modules (files), where each file includes a set of commands
or actions for a single application. These files contain both
server-side code (the logic for \emph{constructing} the ASCII message)
and agent-side code (the logic for \emph{interpreting} the message and
\emph{executing} the command) as a set of classes with a common prefix,
such as `\textless module\_name

There are two major implementation details that should be observed here.
First is that commands are sent through a simple string-based protocol.
This simplicity makes it easy to debug issues that arise as a result of
the protocol itself, but is relatively inflexible. In particular, it is
difficult to send complex Python objects as arguments, since they often
cannot easily be serialized to a string without loss of information. An
example relevant to AKF is passing Playwright browser objects with state
that is difficult to reconstruct using strings alone.

The second implementation detail involves the discovery and execution of
commands indicated by the protocol. As shown previously, ForTrace makes
heavy use of Python's runtime introspection to discover the correct
modules and functions to call based on the contents of a command string.
While this is a valid approach, it is more complex (and difficult to
follow) than the approach taken by AKF.

\subsection{The AKF agent}\label{the-akf-agent}

AKF borrows heavily from the Python agent-based approach of
\textbf{ForTrace}, but improves on its architecture in several respects.
Low-level improvements over ForTrace's agent architecture are described
in more detail in \autoref{comparison-of-fortrace-and-akf-agents}.

Perhaps the most significant change is the use of RPyC for
communication, a library for symmetric remote procedure calls
\cite{TomerfilibaorgRpyc2025}. Although the RPyC protocol is
symmetric, it is often used in typical client-server architectures to
allow clients to manipulate remote Python objects as if they were local
objects, as well as invoke remote (server) functions using local
(client) parameters. By delegating the serialization and deserialization
of complex objects to RPyC, this allows us to perform complex operations
that would have been difficult to implement with the simple string-based
protocol of ForTrace.

In ``new-style'' RPyC, this is achieved by running a \emph{service} on
the device where remote operations should be performed; this service
simply listens on an ephemeral TCP port. Services expose a set of
functions and attributes that may be accessed remotely by an RPyC
client. Application specific-functionality is broken up into individual
RPyC ``subservices'', which are created on demand. The agent's main loop
is itself a ``root'' RPyC service that is responsible for creating and
destroying these subservices upon request; all subservices are known to
the root service at program start, eliminating the need to perform
runtime introspection to find application-specific modules. These
subservices are analogous to the agent-side code of individual ForTrace
modules, interpreting arguments and executing commands on behalf of the
host machine.

Clients are largely decoupled from the server's implementation of
individual services; they do not call or import RPyC service functions
directly. Because the exposed functions (as well as their signatures)
and attributes cannot be inferred from the raw RPyC connection alone,
clients can implement a typed, concrete API to construct RPyC calls.
This allows type checking and autocompletion tools to continue
functioning in development environments. This simultaneously abstracts
the raw RPyC call (and the existence of an RPyC connection) away from
the user, while also providing the signatures of remote functions where
there would otherwise be none. This is analogous to the client-side code
of individual ForTrace modules, constructing messages to the agent to
execute commands.

Additionally, because the service and the API to an RPyC service are
separable, this allows us to break the API (which is used in scenario
scripts) and the agent logic itself into two separate libraries. This
has two advantages -- it may slightly reduce the size of the agent when
installed onto the virtual machine, and it also makes it significantly
easier to build and generate standalone executables using tools like
PyInstaller \cite{PyinstallerPyinstaller2025}. Unlike ForTrace,
whose agent installation process requires a batch script installing
various libraries and Python through the Chocolatey package manager,
AKF's agent requires only that a single executable is copied over and
configured to run on startup (in addition to setting relevant firewall
rules).

From an implementation and usability perspective, this design provides
three major improvements over the ForTrace protocol. First, the routing
of functions is wholly delegated to RPyC. Instead of manually
constructing a message with the function name and its associated
parameters (as strings) over the network, the process of serializing
parameters and routing these parameters to the correct underlying
function call is abstracted away by RPyC.

Second, this allows us to pass and return arbitrarily complex objects
(for which we do not have to write the serialization and deserialization
logic). When passing complex objects from the agent to the server or
vice versa, a reference to the object is sent over the network and
wrapped by a \emph{proxy object}, which behaves like the original object
\cite{TheoryOperationRPyC}. Importantly, it is not necessary to
distinguish between local and remote/proxy objects of the same type when
writing code, which eliminates the extra complexity of using proxies.

Finally, the ability to interact with complex remote objects allows us
to significantly reduce the actual code that is written as part of the
API exposed to the host. For example, there is no need to implement a
wrapper for every method available as part of a Playwright page object;
instead, a reference to the Playwright object \emph{running on the
virtual machine} can be given to the host machine. Instead of writing
individual methods for opening pages, navigating to specific elements,
and so on, we can simply use the methods that already exist in the
Playwright object -- any local calls on the host's proxy object will
lead to remote outcomes on the host, as desired. This, of course, does
not preclude the ability to write convenience methods for complex
actions using that Playwright object.

The list of applications supported by AKF's agent, as well as
implementation-specific details, is described in the table below.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.0376}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2019}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.7606}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Module
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Dependencies
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Details
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Chromium & Playwright \cite{MicrosoftPlaywrightpython2025} & Allows
arbitrary webpages to be visited on Chrome and Edge, as well as perform
complex actions such as completing forms and clicking links based on
HTML selectors \\
\end{longtable}

The generic hypervisor interface is used to support interaction with the
agent. To avoid polluting network captures with agent-related packets,
virtual machines are expected to use a NAT adapter for Internet
communications and a ``maintenance'' host-only adapter for
agent-specific communications. In turn, hypervisor-specific
implementations must expose the ability to discover the IP address of
the host-only adapter. This allows AKF scripts to communicate with the
root RPyC service and any subservices.

\section{Physical artifact
generation}\label{physical-artifact-generation}

\subsection{Overview}\label{overview-1}

\textbf{Physical artifact creation} encompasses any technique in which
virtualization of an operating system is not used to generate artifacts.
This gives the synthesizer the ability to bypass operating system or
driver behavior, which may lead to undesired non-deterministic behavior
for certain actions. This is also referred to as \emph{simulation}, in
contrast with \emph{virtualization}.

For example, a scenario developer may want to guarantee that a
particular deleted file is partially overwritten by another file,
ensuring that the deleted file is recoverable from the slack space of
the newly placed file. However, it is extremely difficult to force the
reuse of the same physical regions from a userspace application.
Operating systems do not expose low-level filesystem functionality to
applications; furthermore, they are still subject to hardware drivers
that regularly rearrange physical space, such as those that engage in
wear leveling.

While it may be possible to predict the outcome of these wear leveling
techniques as demonstrated by Neyaz et al., this is far from the
determinism that may be necessary of research and tool validation
\cite{neyazForensicAnalysisWear2018}. Additionally, background
programs and services may perform file operations that are difficult to
predict. Furthermore, there is also hardware-related non-determinism,
such that caused by faulty hardware or cosmic rays. (It should be noted
that there exists ongoing work in building deterministic platforms, such
as the deterministic hypervisor developed by Antithesis
\cite{pshenichkinYouThinkYou2024}, though outside the scope of this
thesis.) In turn, it is sometimes necessary to bypass the operating
system to reliably place data on a disk.

There are two primary strategies used to achieve physical artifact
creation -- mounting the filesystem and performing direct read/write
operations, and bypassing the filesystem entirely and performing direct
writes to the underlying disk image. Filesystem mounting is leveraged by
several synthesizers, including \textbf{Forensig2} and \textbf{SFX}. For
both of these synthesizers, physical artifact creation is achieved by
simply allowing the user to specify a file to copy from the host machine
to a specific filepath on the disk image.

Other synthesizers, such as \textbf{ForGe} and \textbf{EviPlant},
instead write to the disk image directly. \textbf{ForGe} maintains its
own virtual representation of supported filesystems, using its own data
structures to represent a FAT32/NTFS filesystem. This allows it to
quickly identify and place data in unallocated or slack space. In
contrast, synthesizers such as \textbf{EviPlant} simply allow the user
to provide an offset into the disk image where arbitrary data will be
written to. Both of these techniques involve ``direct writes'', with the
only distinction being filesystem awareness.

It is theoretically possible to construct full forensic datasets through
simulation alone. If a user knows exactly what artifacts are generated
through the execution of an application and \emph{how} these artifacts
are generated, it may be possible to artificially generate these
artifacts as if the application had actually been running. An example
may be editing the history database of a particular browser contained on
a filesystem by mounting it, parsing it, and then adding new entries;
this would make it appear as if the machine was used to browse to these
websites without requiring virtualization.

However, this technique is difficult to implement in practice. For
example, a scenario developer would need to ensure that the artifact is
consistent with other artifacts on disk, since typical Windows
application usage may generate relevant artifacts in prefetch files and
jump lists. Additionally, physical artifact creation does not lend
itself well to generating network captures and volatile memory. Because
no operating system is virtualized, it is naturally the case that there
are no applications making network requests or using volatile memory as
part of execution. Building a network capture or volatile memory dump
from scratch is difficult, at best.

It is important to note that the majority of the artifacts generated by
physical techniques can still be created non-deterministically through
logical means. For example, a user could create files of interest,
delete them, and then write new files to disk through a virtual machine,
possibly leading to the same outcome as simply writing the files
directly to the filesystem without virtualization. However, there is no
strict guarantee in a virtual machine that particular files have
overwritten the space deallocated as a result of deleting the files from
the filesystem. In some cases, this may be acceptable, such as a
scenario in which an instructor simply wants to demonstrate examples of
what might occur when deleting a file.

\subsection{AKF implementation}\label{akf-implementation}

As described in the prior section, there are three techniques for
physical artifact planting implemented by prior synthesizers. These are:

\begin{itemize}
\tightlist
\item
  \textbf{Filesystem mounting}, as done by \textbf{Forensig2} and
  \textbf{SFX}, in which the filesystem is simply mounted to the host
  and edited directly;
\item
  \textbf{Filesystem-independent direct editing}, as done by
  \textbf{EviPlant}, in which edits to specific physical addresses on
  the disk image are made without any parsing or knowledge of the
  underlying filesystem; and
\item
  \textbf{Filesystem-aware direct editing}, as done by \textbf{ForGe}
  and \textbf{EviPlant}, in which filesystem data structures are parsed
  to determine the physical address(es) of the disk image to write to.
  (How EviPlant achieves this is not known.)
\end{itemize}

AKF supports all three to varying degrees, with significant improvements
over prior synthesizers specifically in filesystem-aware editing.

With respect to filesystem mounting, AKF allows users to construct new
ISO files from an existing host directory using the
\passthrough{\lstinline!pycdlib!} library
\cite{lalancetteClalancettePycdlib2025}. These ISOs can be used as
standalone artifacts (for example, presenting it to students as a disk
image of a removable drive), in addition to mounting them as removable
storage on a running virtual machine. Mounting these ISOs, as well as
setting up a shared network folder between the host and guest machines,
are the simplest means through which scenario developers can transfer
files onto a running virtual machine. AKF does not currently support
writing to arbitrary filesystems or disk image formats at rest, since
these require write capabilities not supported by any well-known
library.

AKF also trivially ``supports'' filesystem-independent direct editing.
Python allows users to open files in binary-mode, at which point the
user can call \passthrough{\lstinline!seek()!} on the file pointer to
advance the pointer to a specific offset in the file. The user can then
call \passthrough{\lstinline!write()!} to overwrite an arbitrary number
of bytes at that position, achieving the same outcome as many other
synthesizers that implement range and offset-based disk image editing.

Although blindly writing to arbitrary positions is not always viable for
correctly placing artifacts on a disk image (for example), it is still a
valid approach when the underlying filesystem already been analyzed
ahead of time and the exact offsets and ranges to write are known. This
may be the approach used by \textbf{EviPlant} to construct and leverage
its evidence packages for students; because filesystem analysis is
costly and requires libraries compared to offset-based editing, it is
easier to perform this analysis at construction time and distribute the
offsets to which data must be written to base images.

In many cases, however, the filesystem may not have been analyzed ahead
of time such that the exact offsets and data needed to place a file on
disk are known. This brings us to filesystem-aware direct editing, which
AKF makes significant improvements in.

ForGe implements its physical artifact generation by implementing NTFS
and FAT32 data structures in Python, allowing it to create a fully
virtual representation of these filesystems (with the assistance of a
custom C program). This provides it with the information necessary to
insert data into known slack and unallocated space in an efficient
manner while keeping the filesystem consistent. While extremely powerful
(and implements a valuable feature not found in any other synthesizer to
date), it is inflexible in two specific aspects:

\begin{itemize}
\tightlist
\item
  ForGe does not provide a generic interface for the filesystems it
  supports. Although both the NTFS and FAT32 wrappers provide the same
  methods with the same signatures, this is not strictly enforced by a
  parent class. This means that the common functionality it supports
  across all filesystems is unclear, as is the functionality that must
  be implemented for new filesystems to be compatible with ForGe.
\item
  ForGe lacks a ``frontend'' to support arbitrary disk types, regardless
  of the underlying filesystem. ForGe does not support multi-partition
  disks, nor does it support common non-raw disk formats such as VHD,
  VMDK, and VDI.
\end{itemize}

Read-only libraries addressing these two issues have been in development
since the introduction of ForGe, but have not been integrated into other
synthesizers to achieve the same write capabilities as ForGe. One such
library is \passthrough{\lstinline!libtsk!} (also known as The Sleuth
Kit), the C++ library that powers the open-source digital forensics
platform Autopsy \cite{SleuthkitSleuthkit2025}.
\passthrough{\lstinline!libtsk!} allows users to navigate and analyze
the low-level contents of a variety of filesystems, including
filesystem-specific attributes and the sequence of disk clusters that
form a file. \passthrough{\lstinline!libtsk!} supports a large variety
of filesystems through a filesystem-agnostic interface, including the
FAT family of filesystems, the ext family, NTFS, and a variety of other
filesystems. It also supports a variety of volume systems (partition
schemes for multi-partition disks), such as GPT and MBR, as well as a
small number of filesystem containers and images.

Python bindings for \passthrough{\lstinline!libtsk!} have existed for at
least 15 years, with the most commonly used library being the
automatically generated \passthrough{\lstinline!pytsk!}
\cite{Py4n6Pytsk2025}. However, \passthrough{\lstinline!pytsk!} has
relatively limited Python documentation and adoption, in addition to
inheriting various known issues and limitations in
\passthrough{\lstinline!libtsk!}, such support for niche filesystems and
partitioning formats. Many of these gaps were gradually covered as part
of the \passthrough{\lstinline!libyal!} project, a collection of DFIR
libraries developed by various contributors - most notably Joachim Metz
from Google. The \passthrough{\lstinline!libyal!} project includes
individual libraries for analyzing formats not supported by
\passthrough{\lstinline!libtsk!} such as the QCOW disk image format used
by QEMU, the Apple File System used by modern Apple devices, and more.

This leads to the use of \passthrough{\lstinline!dfvfs!}, or the Digital
Forensics File System, a Python library that leverages
\passthrough{\lstinline!libtsk!} and multiple libraries from the
\passthrough{\lstinline!libyal!} project to provide a generic interface
for analyzing a variety of disk image formats and filesystems
\cite{Log2timelineDfvfs2025}. (The project is derived from Plaso and
Google Rapid Response, two open-source DFIR tools used in a variety of
contexts.) Much like \passthrough{\lstinline!libtsk!}, it exposes a
variety of low-level filesystem concepts that are common across multiple
filesystems, such as the metadata and individual segments that comprise
a file at a known path on the filesystem. This low-level detail, in
combination with its focus on exposing this detail through a consistent
Python interface, makes it extremely powerful in performing
filesystem-aware direct editing.

AKF uses \passthrough{\lstinline!dfvfs!} to locate the clusters of a
file at a known path in a filesystem, which can then be used to identify
the start of slack space within the file's clusters (as well as
unallocated space in the filesystem). By adding the physical offset of
the cluster within the filesystem to the offset of the filesystem's
partition in the disk image, AKF can write to the exact location of a
file's slack space using the offset-based method described earlier. (It
should be noted that this technique does not work on filesystems with
full disk encryption enabled, as is the default on Windows systems
beginning with the Windows 11 24H2 update.)

This achieves feature parity with ForGe, completely delegating
filesystem and image-specific details to \passthrough{\lstinline!dfvfs!}
and allowing for a filesystem-independent method for locating slack
space. This provides a deterministic method for inserting data within
the slack space of a filesystem, simulating the deallocation of a file
and its partial replacement with a known file. However, this does not
fully simulate the process of deleting a file through a running
operating system and having a new file replace the deallocated clusters;
naturally, this does not generate OS-specific artifacts associated with
deleting and creating files, and fails to generate the filesystem
artifacts that \emph{could} exist with the original file (such as the
``deleted'' file's name in the NTFS master file table). Additional
opportunities to leverage \passthrough{\lstinline!dfvfs!} in other
physical artifact generation techniques exist.
