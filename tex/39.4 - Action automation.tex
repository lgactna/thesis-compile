This chapter addresses the modules responsible for automating artifact
generation, depicted in the partial architectural diagram below.

!\textbf{39.4 - Action automation 2025-02-07 17.15.30.excalidraw}

These implement AKF's ability to generate individual artifacts as part
of a larger scenario dataset. This chapter begins with an overview of
the techniques used by prior synthesizers for generating artifacts. It
then moves to a low-level analysis of the actual implementation used by
AKF, while comparing these techniques to other synthesizers.

In particular, this chapter addresses the role of the action automation
library in generating artifacts by interacting with a live virtual
machine and disk images stored on the host. It describes how logical
artifacts are generated at a lower level, both directly through
hypervisor APIs and through an OS-specific agent installed on the
virtual machine. It concludes by describing the generation of physical
artifacts through direct filesystem and disk image editing.

\subsection{Overview}\label{overview}

At the core of every synthesizer is the ability to place or otherwise
generate forensic artifacts. Each of the synthesizers described in
\ref{analysis-of-existing-synthesizers} takes one of three approaches to artifact generation, as
partly described by Scanlon et al.
\cite{scanlonEviPlantEfficientDigital2017}:

\begin{itemize}
\item
  \textbf{Physical}: No virtualization of software or hardware ever
  occurs; data is written directly to the target medium, such as a disk
  image or virtual hard drive.\\
\item
  \textbf{Agentless logical}: The synthesizer interacts with a live VM
  to generate artifacts. Interaction is achieved without the need for
  custom software to be installed on the VM, and is typically achieved
  through the hypervisor itself or a remote management tool native to
  the virtualized operating system.\\
\item
  \textbf{Agent-based logical:} The synthesizer interacts with a
  dedicated client (agent) on a live VM to carry out actions. The VM
  must have the agent installed before any interaction can occur.
\item
  \textbf{Agent-based logical:} The synthesizer interacts with a
  dedicated client (agent) on a live VM to carry out actions. The VM
  must have the agent installed before any interaction can occur.\\
  hese three approaches are not mutually exclusive within a single
  synthesizer, though it is the case that most prior synthesizers have
  used exactly one approach to generate artifacts. The table below
  denotes the approaches used by each of the synthesizers previously
  discussed. Where source code is not available, a best effort is made
  to identify the approach used by a particular synthesizer based on its
  published paper, if one exists; otherwise, the entire row contains
  question marks.
\end{itemize}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1799}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.4604}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1942}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1655}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Synthesizer
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Physical
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Agentless
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Agent-based
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{FALCON}, 2005 & ? & ? & ? \\
\textbf{CYDEST}, 2008 & ? & ? & ? \\
\textbf{Forensig2}, 2009 & Yes (mounting filesystem, writing directly to
disk using offset) & Yes (over SSH only) & No \\
\textbf{D-FET}, 2011 & Yes (mounting filesystem, writing directly to
disk using offset) & No & No \\
\textbf{SFX}, 2012 & Yes (mounting filesystem) & No & No \\
\textbf{Yannikos et al.}, 2014 & ? & ? & ? \\
\textbf{ForGeOSI}, 2014 & No & Yes (hypervisor interfaces) & No \\
\textbf{ForGe}, 2015 & Yes (emulates complete filesystem in memory as
Python objects) & No & No \\
\textbf{ForGen}, 2016 & No & No & No \\
\textbf{EviPlant}, 2017 & Yes (write directly to image file using
offset) & No & Yes (unknown mechanism) \\
\textbf{VMPOP}, 2018 & No & Yes (hypervisor interfaces) & No \\
\textbf{hystck}, 2020 & No & No & Yes (Python agent) \\
\textbf{TraceGen}, 2021 & No & No & Yes (unknown mechanism) \\
\textbf{ForTrace}, 2022 & No & No & Yes (Python agent) \\
\end{longtable}

There are advantages and disadvantages to each approach, in addition to
requiring distinct implementation techniques for each. The remainder of
this chapter analyzes these each of these three approaches in greater
detail, describing the implementation details of prior synthesizers and
comparing them to those of AKF's.

\subsection{Agentless artifact
generation}\label{agentless-artifact-generation}

\subsubsection{Hypervisor
interfaces}\label{hypervisor-interfaces}

\textbf{Agentless artifact creation} describes one of two general
techniques. The first is emulating ``normal'' human interaction by
leveraging hypervisor interfaces -- such as the monitor, keyboard, and
mouse -- to manipulate a GUI-based operating system directly. This is
the approach taken by \textbf{VMPOP} and \textbf{ForGeOSI}; for example,
VMPOP leverages the VirtualBox API to interact with supported
applications. More precisely, it typically uses a sequence of keyboard
strokes to focus and interact with UI elements, such as clearing User
Account Control dialogs on Windows or starting applications with Win+R.

Strictly speaking, this approach most accurately reflects how a real
human would interact with a machine. In many cases, this greatly reduces
the \textbf{Synthesis pollution} that occurs. However, this tends to
lead to verbose scripts that are only capable of performing very
specific actions. The keyboard and mouse actions required to fulfill a
particular action can change significantly between versions of the same
application, versions of the same operating system, and varying screen
sizes.

For example, VMPOP handles UAC prompts on machines prior to Windows 7 by
sending an Alt+Tab keystroke to the machine, clicking the mouse at the
center of the screen to focus the UAC prompt, and then sending Alt+C to
accept the prompt. On machines running Windows 7 or later, this is
instead achieved by focusing the UAC prompt with the mouse and then
sending Alt+Y to accept the prompt.

Similarly, VMPOP interacts with browsers exclusively through the use of
keyboard shortcuts. VMPOP supports simple interactions with a small
number of websites, such as logging into Microsoft or Google, but is
dependent on the form elements remaining the same over time. That is,
VMPOP does not inspect the contents of the current webpage to perform
actions, and cannot react to design changes. If there are new focusable
elements on the page, the same keystroke sequence may no longer achieve
the desired effect. This lack of runtime logic, which amounts to
operating the machine with the monitor off, leads to brittle scripts
that can be tedious to fix.

It is worth noting that throughout this thesis, the use of
hypervisor-specific guest software, such as VirtualBox Guest Additions
and VMWare Tools, is treated as an agentless approach throughout this
thesis. Although this inherently requires the installation of
``unusual'' software on the virtual machine, it is sufficiently distinct
from typical user software that it is unlikely to generate artifacts
that complicate a scenario. In most cases, artifacts generated by
hypervisor guest software can be noted, isolated, and ignored.

\textbf{TraceGen} notes that the ideal future is to use some combination
of computer vision and AI to generalize user actions. Currently,
completing the action of ``performing a Google Search in Microsoft
Edge'' would likely be achieved through a sequence of predefined
keystrokes. While this is explored in greater detail in \textbf{39.8 -
Future work}, recent advancements in LLMs may make it possible to allow
a machine to perform arbitrarily complex tasks on a GUI-based operating
system using natural language - an approach that can be integrated into
AKF.

\subsubsection{Management utilities}\label{management-utilities}

The alternative is to use existing management utilities, typically a
shell, which are native to the virtualized operating system and are
capable of carrying out commands. This can be further broken down into
two categories: local management utilities, such as Bash and PowerShell,
and remote management utilities, such as SSH and WinRM.

Local management utilities typically refer to scripting languages that
are available as part of the operating system, and can be used to manage
most or all operating system resources. For example, PowerShell allows
users to modify registry keys, invoke applications, create users, and
more. Similarly, any standard Linux terminal program, such as Bash or
Zsh, can be used to install packages and run a variety of command-line
applications. This is typically invoked by either opening and focusing a
terminal window (such as the Win+R shortcut on Windows), or by directly
executing scripts through the hypervisor guest additions.

In particular, \textbf{VMPOP} makes heavy use of local management
utilities; it implements much of its functionality through a collection
of PowerShell and batch scripts. For example, VMPOP allows users to
focus a window by PID, process name, or window title. This is achieved
by getting a PowerShell handle to the process using
\texttt{Get-Process}, using \texttt{Add-Type} to add a local C\#
function that is capable of sending keyboard events through
\texttt{user32.dll}, and then holding the Alt key while using
\texttt{AppActivate} to focus the window and bring it to the foreground.
VMPOP leverages similar scripts for launching and terminating processes
by name, uninstalling programs, creating a Windows restore point, and
more.

In Similarly, remote management utilities allow a remote device to
invoke local management utilities, typically over an SSH server or
WinRM. In most architectures, the use of remote management utilities
requires that the host and guest machines can communicate with each
other, which is typically achieved through a NAT or host-only interface
managed by the hypervisor. This approach is taken by \textbf{Forensig2},
which exclusively connects to a running SSH server to carry out user
actions.

The use of remote management utilities to automate actions typically
undertaken by users is not uncommon, especially among general
infrastructure as code solutions. For example, the open-source Ansible
framework simplifies the configuration of Windows and Linux devices to
simple, YAML-based files called ``playbooks''. These playbooks typically
contain a sequence of high-level tasks to perform, such as installing
packages, managing local user accounts, running scripts, and more.

It is worth noting that although this approach does not require
installing new software on the machine, most operating systems perform
some degree of logging when their management utilities are invoked. For
example, the \texttt{sshd} daemon logs connections regardless of which
network interface is used, which may make it difficult to separate or
remove logs not related to SSH connections as part of the scenario
itself. Similarly, the invocation of PowerShell scripts causes event
logs to be generated, which can be particularly noisy if Script Block
Logging (which logs the execution and content of all PowerShell scripts)
is active.

\subsubsection{AKF agentless
generation}\label{akf-agentless-generation}

AKF allows users to perform agentless artifact creation through a
dedicated hypervisor-agnostic interface (`akflib.\textless something

(What functionality is available through the hypervisor interface, as
well as the VirtualBox API in particular?)

(What agentless functionality in \textbf{VMPOP} do we instead delegate
to the agent, such as interacting with browsers? why is this a good
thing, and what do we lose as a result?)

\begin{itemize}
\item[$\square$]
  \#todo explain the hypervisorbase
\item[$\square$]
  \#todo explain the hypervisorbase
\end{itemize}

\section{Agent-based artifact
generation}\label{agent-based-artifact-generation}

\textbf{Agent-based artifact creation} involves the use of a dedicated
program on the VM that serves as an interface between the host machine
and the guest machine. This program runs commands natively on the
virtual machine on behalf of the host machine, typically accepting
commands over a dedicated network interface. This allows for greater
flexibility and more complex actions to be taken. In particular, it
allows for existing automation frameworks such as Playwright and
PyAutoGUI to be used in implementing application-specific functionality.
However, this approach often leads to \textbf{Synthesis
pollution\textbar synthesis pollution}; besides the presence of software
that would never exist on a typical user's machine, agents often do not
interact with applications the same way that a human would. In this
case, the synthesizer should document known pollution that can be
ignored for educational and testing purposes.

\subsubsection{Analysis of the ForTrace
agent}\label{analysis-of-the-fortrace-agent}

Agent-based artifact creation is the approach taken by
\textbf{hystck}/\textbf{ForTrace}, which refers to its agent as an
``interaction manager''. Because ForTrace provides the largest set of
functionality for its agents, and is by far the most mature synthesizer,
AKF's agents borrow heavily from ForTrace's approach. As a result, a
detailed analysis of ForTrace's design is provided here.

ForTrace agents are simply an entire copy of the ForTrace codebase
copied over to the virtual machine -- that is, the ``agent'' and
``server'' share the same codebase, but have different entry-points and
call different functions. Application-specific functionality for agents
is organized into individual modules (files), where each file separates
a set of commands or actions for a single application.

The server, or ``virtual machine monitor'' (VMM), issues commands over
TCP to a running instance of the agent on the VM. Invoking commands
entails issuing a simple string to the agent running on the VM. For
example, invoking a command to add a new user to the VM may look like
the following:

REPLACE CODEBLOCK HERE

The agent's main loop, which receives and interprets these commands, is
extremely simple:

REPLACE CODEBLOCK HERE

When the \texttt{Agent} is first instantiated, it forms a permanent TCP
socket out to the configured port and IP address where it expects the
server (the VMM) to be issuing commands.
\texttt{Agent.receiveCommands()} receives every message available by
reading the socket, parsing it, and then invoking
\texttt{Agent.do\_command()}, which converts the command message into a
specific Python function call with arguments.

Each module under \texttt{fortrace.application} can be thought of as a
coherent group of commands associated with a particular \emph{real}
application (like Firefox or Thunderbird). Recall earlier how we found
our \texttt{userManagement} application and invoked \texttt{addUser}:

REPLACE CODEBLOCK HERE

At a high level, the \texttt{application()} call attempts to import
\texttt{fortrace.application.\{application\_name\}}. Although not
enforced by a higher-level interface, each of these modules contains
subclasses of the following four classes (defined in
\texttt{fortrace.application.application}) at minimum, with possibly
more helper classes for OS-specific functionality or other modularity as
needed:

\begin{itemize}
\item
  \texttt{ApplicationVmmSide}: Contains one function for each command
  implemented in \texttt{ApplicationGuestSide}, building a message that
  will be interpreted and acted upon by the corresponding
  \texttt{ApplicationGuestSideCommands} class.
\item
  \texttt{ApplicationVmmSideCommands}: Accepts and interprets
  module-specific messages returned by the agent, which may be used to
  update the remote state as tracked by the host.
\item
  \texttt{ApplicationGuestSide}: Implements the actual
  application-specific functionality for the agent, providing one
  function for each separated command by this module.
\item
  \texttt{ApplicationGuestSideCommands}: Interprets commands and
  arguments, calling the respective function in the corresponding
  \texttt{ApplicationGuestSide} subclass. This allows the actual
  dispatch of commands to be delegated to this class, which is free to
  choose how actions are performed (threading, multiprocessing, etc.) as
  well as any module-wide state it may need to maintain.
\item
  \texttt{ApplicationGuestSideCommands}: Interprets commands and
  arguments, calling the respective function in the corresponding
  \texttt{ApplicationGuestSide} subclass. This allows the actual
  dispatch of commands to be delegated to this class, which is free to
  choose how actions are performed (threading, multiprocessing, etc.) as
  well as any module-wide state it may need to maintain. his naming
  convention is intentional. As will be shown later, the word
  \texttt{Application} is replaced with the name of the module in
  camelcase. For example, \texttt{fortrace.application.userManagement}
  contains \texttt{UserManagementVmmSide},
  \texttt{UserManagementVmmSideCommands}, and so on. Discovering and
  getting handles to these classes is performed through string
  manipulation of the relevant application's module name, as shown in
  the example below:
\end{itemize}

REPLACE CODEBLOCK HERE

In the example above, \texttt{UserManagementGuestSide.addUser()}
contains the literal code to execute on the guest when
\texttt{addUser()} is called, such as adding the registry keys needed
for a user to be created. On the other hand,
\texttt{UserManagementVmmSide.addUser()} contains the code to send a
message over TCP that the agent will understand, eventually leading to
the execution of the agent's version of \texttt{addUser()}.

More precisely, the \texttt{ApplicationVmmSide} subclass effectively
serves as the API for calling the associated functions in the
\texttt{ApplicationGuestSide} class running on the virtual machine. This
subclass, along with the complete agent-side code, is stored in a single
file. For example, the API and code for opening a Firefox browser window
is as follows:

REPLACE CODEBLOCK HERE

Calling the \texttt{open()} command from the host causes a message of
the following form to be sent to the agent:

REPLACE CODEBLOCK HERE

Upon receiving this message, the agent's main loop will search for the
\texttt{webBrowserFirefox} module and import its corresponding
\texttt{ApplicationGuestSideCommands} subclass. After any state
management, the subclass will then search for a function called
\texttt{open} in its corresponding \texttt{ApplicationGuestSide} class,
as implemented below:

REPLACE CODEBLOCK HERE

There are two major implementation details that should be observed here.
As mentioned previously, commands are sent through a simple string-based
protocol. This simplicity makes it easy to debug issues as a result of
the protocol, but is relatively inflexible. In particular, it is
difficult to send complex objects that cannot easily be serialized to a
string without loss of information, such as Playwright browser objects
with state that is difficult to reconstruct using strings alone.

The second implementation detail involves the discovery and execution of
commands indicated by the protocol. As shown previously, ForTrace makes
heavy use of Python's runtime introspection to discover the correct
modules and functions to call based on the contents of a command string.
While this is a valid approach, it is significantly more complex than
the approach taken by AKF.

\subsubsection{The AKF agent}\label{the-akf-agent}

AKF borrows heavily from the Python agent-based approach of
\textbf{ForTrace}, but improves on its architecture in several respects.

Perhaps the most significant change is the use of RPyC for
communication, a library for symmetric remote procedure calls
\cite{TomerfilibaorgRpyc2025}. Although the RPyC protocol is
symmetric, it is often used in client-server architectures to allow
clients to manipulate remote Python objects as if they were local
objects, as well as invoke remote functions using local parameters. By
delegating the serialization and deserialization of complex objects to
RPyC, this allows us to perform complex operations that would have been
difficult to implement with the simple string-based protocol of
ForTrace.

In ``new-style'' RPyC, this is achieved by running a \emph{service} on
the device where remote operations should be performed; this service
simply listens on an ephemeral TCP port. Services expose a set of
functions and attributes that may be accessed remotely by an RPyC
client. This is analogous to the \texttt{ApplicationGuestSideCommands}
and \texttt{ApplicationGuestSide} classes of individual ForTrace
modules.

Because the exposed functions (as well as their signatures) and
attributes cannot be inferred from the raw RPyC connection alone,
clients can implement a typed, concrete API that allows type-hints and
autocompletion features to continue working in development environments.
This simultaneously abstracts the raw RPyC call (and the existence of an
RPyC connection) away from the user, while also providing the remote
function signatures where there would otherwise be none. This is
analogous to the \texttt{ApplicationVmmSide} and
\texttt{ApplicationVmmSideCommands} classes of ForTrace modules.

For example, a simple RPyC service and its corresponding API may be
implemented as follows:

REPLACE CODEBLOCK HERE

This syntax provides three major improvements over the ForTrace
protocol. First, the routing of functions is wholly delegated to RPyC.
Instead of manually constructing a message with the function name and
its associated parameters (as strings) over the network, implementing
support for a particular service on the client-side API is as simple as
calling an untyped function \texttt{rpyc\_conn.root.set\_browser()}. By
wrapping it around a typed function,
\texttt{ChromiumServiceAPI.set\_browser()}, users regain the ability to
use code completion and static linting tools.

Second, this allows us to pass and return arbitrarily complex objects
for which we do not have to write the serialization and deserialization
logic for. When passing complex objects from the agent to the server or
vice versa, a reference to the object is sent over the network and
wrapped by a \emph{proxy object}, which behaves like the original object
\cite{TheoryOperationRPyC}. Importantly, it is not necessary to
distinguish between local and remote/proxy objects of the same type when
writing code, which elements the extra complexity of using proxies.

Finally, the ability to interact with complex remote objects allows us
to significantly reduce the actual code that is written as part of the
API exposed to the host. For example, there is no need to implement a
wrapper for every method available as part of a Playwright page object;
instead, a reference to the Playwright object \emph{running on the
virtual machine} can be given to the host machine. Instead of writing
individual methods for opening pages, navigating to specific elements,
and so on, we can simply use the methods that already exist in the
Playwright object -- any local calls on the host's proxy object will
lead to remote outcomes on the host, as desired.

Application specific-functionality is broken up into individual RPyC
``subservices'', which are created on demand. The agent's main loop is
itself a ``root'' RPyC service that is responsible for creating and
destroying these subservices upon request; all subservices are known to
the root service at program start, eliminating the need to perform
runtime introspection to find application-specific modules.

Additionally, because the service and the API to an RPyC service are
separable, this allows us to break the API (which is used in scripts)
and the agent logic itself into two separate libraries. This has two
advantages -- it may slightly reduce the size of the agent when
installed onto the virtual machine, and it also makes it significantly
easier to build and generate standalone executables using tools like
PyInstaller. Unlike ForTrace, whose agent installation process requires
a batch script installing various libraries and Python through the
Chocolatey package manager, AKF's agent requires only that a single
executable is copied over and configured to run on startup (in addition
to setting relevant firewall rules).

The list of applications supported by AKF's agent, as well as
implementation-specific details, is described in the table below.

\begin{itemize}
\item[$\square$]
  \#todo shoot for feature parity with ForTrace; see page 11 of its
  paper for what it supports
\item[$\square$]
  \#todo shoot for feature parity with ForTrace; see page 11 of its
  paper for what it supports Module \textbar{} Dependencies \textbar{}
  Details \textbar{} \textbar{} -------- \textbar{}
  ------------------------------------------- \textbar{}
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------
  \textbar{} \textbar{} Chromium \textbar{} Playwright
  \cite{MicrosoftPlaywrightpython2025} \textbar{} Allows arbitrary
  webpages to be visited on Chrome and Edge, as well as perform complex
  actions such as completing forms and clicking links based on HTML
  selectors \textbar{}
\end{itemize}

\subsection{Physical artifact
generation}\label{physical-artifact-generation}

\subsubsection{Overview}\label{overview-1}

\textbf{Physical artifact creation} encompasses any technique in which
virtualization of an operating system is not required to generate
artifacts. This gives the synthesizer the ability to bypass operating
system or driver behavior, which may lead to non-deterministic behavior
for certain actions. For example, a scenario developer may want to
guarantee that a particular deleted file is partially overwritten by
another file, allowing that the deleted file is recoverable from the
slack space of the newly placed file.

However, there is no known method for reliably reusing the same logical
block from userspace. Operating systems do not expose low-level
filesystem functionality to applications; furthermore, they are still
subject to hardware drivers that regularly rearrange physical space,
such as those that engage in wear leveling. While it may be possible to
predict the outcome of these wear leveling techniques as demonstrated by
Neyaz et al., this is far from the determinism that may be necessary of
research and tool validation \cite{neyazForensicAnalysisWear2018}.
Additionally, background programs and services may perform file
operations that are difficult to predict.

In turn, it is sometimes necessary to bypass the operating system
entirely to reliably place data on a disk. There are two primary
techniques used to achieve this -- mounting the filesystem and
performing direct read/write operations, and bypassing the filesystem
entirely and performing direct writes to the underlying disk image.

Filesystem mounting is leveraged by several synthesizers, including
\textbf{Forensig2} and \textbf{SFX}. For both of these synthesizers,
physical artifact creation is achieved by simply allowing the user to
specify a file to copy from the host machine to a specific filepath on
the disk image. Other synthesizers, such as \textbf{ForGe} and
\textbf{EviPlant}, instead write to the disk image directly.
\textbf{ForGe} maintains its own representation of supported
filesystems, using its own data structures to represent a FAT32/NTFS
filesystem. This allows it to quickly identify and place data in
unallocated or slack space. In contrast, synthesizers such as
\textbf{EviPlant} simply allow the user to provide an offset into the
disk image where arbitrary data will be written to.

It is important to note that the majority of the artifacts generated by
physical techniques can still be created non-deterministically through
logical means. Users can create files of interest, delete them, and then
write new files to disk through a virtual machine; this \emph{may}
result in the desired outcome, but there is no strict guarantee that
particular files have overwritten data in now-unallocated space. In some
cases, this may be acceptable, such as a scenario in which an instructor
simply wants to demonstrate that file recovery from slack is possible.

It is also worth noting that artifact creation does not lend itself well
to generating network captures and volatile memory, since no operating
system is virtualized and therefore no applications (that would normally
perform requests over the internet) are executed. However, it is
theoretically possible to build forensic datasets through simulation
alone; if a user knows exactly what artifacts are generated through the
execution of an application and \emph{how} these artifacts are
generated, it may be possible to artificially generate these artifacts
as if the application had actually been run.

An example may be editing the history database of a particular browser
contained on a filesystem by mounting it, parsing it, and then adding
new entries; this would make it appear as if the machine was used to
browse to these websites without requiring virtualization. However, this
technique is difficult to implement in practice. For example, a scenario
developer would need to ensure that the artifact is consistent with
other artifacts on disk, since typical Windows application usage may
generate relevant artifacts in prefetch files and jump lists.

\subsubsection*{4.4.2 - AKF implementation}\label{akf-implementation}
\addcontentsline{toc}{subsubsection}{4.4.2 - AKF implementation}
